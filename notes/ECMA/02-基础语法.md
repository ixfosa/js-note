## Hello, world!

运行环境

+ 浏览器环境
+ node 环境



浏览器环境

+ JavaScript 程序可以在 `<script>` 标签的帮助下插入到 HTML 文档的任何地方。

+  引入外部脚， 脚本文件可以通过 src 特性（attribute）添加到 HTML 文件中

  + `<script src="/path/to/script.js"></script>`

    >   注意：一个单独的 `<script>` 标签不能同时有 src 特性和内部包裹的代码。

```html
<!DOCTYPE HTML>
<html>
<body>
  <p>script 标签之前...</p>
    
  <script>
      
    alert('Hello, world!');
  </script>
    
  <p>...script 标签之后</p>
</body>
</html>
```



node 环境

+ node   js_file

```js
// 文件名 hello.js
console.log( 'Hello World!' );

// cmd: node  hello.js
```



## 代码结构

### 语句

语句是执行行为（action）的语法结构和命令。

```js
// 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。
console.log( 'Hello World!' );console.log( 'Hello World!' );

// 通常，每条语句独占一行，以提高代码的可读性：
console.log( 'Hello World!' );
console.log( 'Hello World!' );

// 空语句,表示3个空语句。
;;;
```



### 分号

  当存在换行符（line break）时，在大多数情况下可以`省略分号`。

```js
// 可以运行。在这，JavaScript 将换行符理解成“隐式”的分号。这也被称为 自动分号插入。
console.log( 'Hello World!' );
console.log( 'Hello World!' );

// 有很多时候换行并不是分号
// 如果一行以加号 "+" 结尾，那么这是一个“不完整的表达式”，不需要分号。
console.log( 1 + 
            2
            + 3 );

 [1, 2].forEach(console.log)  // 错误的例子
```



### 注释

+  `单行注释`以两个正斜字符 `//` 开始。
+  `多行注释`以一个正斜杠和星号开始 “/*” 并以一个星号和正斜杠结束 “*/”。
  +   不支持注释嵌套

```js
// 单行注释

/*
	多行注释
*/
console.log( 'Hello World!' );
```



## 严格模式 "use strict"

+ "use strict"，为了兼容旧代码
+ "use strict" 来明确地激活这些ES5（以后版本）特性。
+ 一旦进入了严格模式，就没有回头路了。没有办法取消 use strict
+ 开发者控制台 运行代码时，请注意它默认是不启动 use strict 的。
  + 控制台中添加 ` 'use strict';` <Shift+Enter 换行>

```js
"use strict";
	// 代码以现代模式工作
    // ...


// 立执行函数内部有效
(function() {
    'use strict';
  
    // ...你的代码...
})()
```





## 变量 和 常量

### 变量

创建一个变量，需要用到 `let` 或 `var` 关键字。

+ 变量命名

  + 变量名称必须仅包含字母，数字，符号`$` 和 `_`。
  + 首字符必须`非数字`。
  + 允许非英文字母，但不推荐
  + `区分大小写`
  + 不允许使用保留字或关键字命名
    + 比如，let、var、class、return、function 都被保留了。
  + 一般，需要在使用一个变量前定义它
    + 在早期，可以不使用 let 进行变量声明，而可以简单地通过赋值来创建一个变量。现在如果我们不在脚本中使用 use strict 声明启用严格模式，这仍然可以正常工作，为了保持对旧脚本的兼容

  

  > 如果命名包括多个单词，通常采用驼峰式命名法（camelCase）。也就是，单词一个接一个，除了第一个单词，其他的每个单词都以大写字母开头：myVeryLongName。

```java
// 下面的命名是有效的：
let $ = 1; // 使用 "$" 声明一个变量
let _ = 2; // 现在用 "_" 声明一个变量
console.log($ + _); // 3


// 下面的变量命名不正确：
// let 1a; // 不能以数字开始
// let my-name; // 连字符 '-' 不允许用于变量命名
```



```java
// 创建（也可以称为 声明 或者 定义）了一个名称为 “name” 的变量
// 将变量定义和赋值合并成一行：
let name = "ixfsoa";

// 通过赋值运算符 = 为变量添加一些数据：
let message;
message = "hello js";   // 保存字符串
console.log(message);   // 显示变量内容 
```

```java
// 在一行中声明多个变量：
// 不推荐这样。为了更好的可读性，请一行只声明一个变量。
let user = "ixfosa", sex = "man";
console.log(`user: ${user} , age: ${age}`);

// 一行只声明一个变量。
let user = "ixfosa"
let sex = "man";
```

```java
let buf;
buf = "js";
buf = "JavaScript";   // 当值改变的时候，之前的数据就被从变量中删除了：
console.log("buf: " + buf);
```

```js
// 声明两个变量，然后将其中一个变量的数据拷贝到另一个变量。
let str1 = "hello js";
let str2;
str2 = str1;
console.log(`str1: ${str1}`);
console.log(`str2: ${str2}`);
```

```js
// 声明两次会触发 error
// 一个变量应该只被声明一次。

// 对同一个变量进行重复声明会触发 error：
let info = "error";
let info = "warn"   // SyntaxError: Identifier 'info' has already been declared
```

```js
// 注意：没有 "use strict"
num = 5; // 如果变量 "num" 不存在，就会被创建
console.log(num); // 5
// 糟糕的做法，严格模式下会报错。


"use strict";
num = 5; // 错误：num 未定义
```



### 常量

+ 声明一个常数（不变）变量，可以使用 `const ` 而非 let
+ 定义常量要同时赋值
+ `不能被修改`，如果尝试修改就会发现报错
+ 通常使用大写字母和下划线来命名这些常量。

```js
// 声明一个常数（不变）变量，可以使用 const 而非 let：
const PI = '3.14';

// 使用 const 声明的变量称为“常量”。它们不能被修改，如果你尝试修改就会发现报错：
PI = '3.15'; // TypeError: Assignment to constant variable.
```





## 数据类型

### 数据类型基本概览

数据类型作用：

+ 确定 数据的储存大小
+ 确定  数据所能参与的运算



JavaScript 中的 数据类型

+ Number
+ String
+ Boolean
+ null
+ undefined
+ Objects
  + Arrays
  + Function
  + Date
  + 等等。。。

> 原始类型（基本类型）：按值访问，可以操作保存在变量中实际的值。null和undefined比较特殊。
>
> 引用类型：引用类型的值是保存在内存中的对象。
>
> + 不能直接操作对象的内存空间
>
> + 值是按引用访问的



> BigInt 类型
>
> + 在 JavaScript 中，“number” 类型无法表示大于 `(253-1)`（即 `9007199254740991`），或小于 `-(253-1)` 的整数。
> + `BigInt` 类型 用于表示任意长度的整数。
> + 通过将 `n` 附加到整数字段的末尾来创建 `BigInt` 值。
> + 目前 Firefox/Chrome/Edge/Safari 已经支持 `BigInt` 了，但 IE 还没有。
>
> ```javascript
> // 尾部的 "n" 表示这是一个 BigInt 类型
> const bigInt = 1234567890123456789012345678901234567890n;
> ```



> symbol 类型
>
> + `symbol` 类型用于创建对象的唯一标识符。

### Number

JavaScript不区分整数和浮点数，统一用Number表示

```javascript
// 以下都是合法的Number类型：
123;      // 整数123
0.456;    // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99;      // 负数
NaN;      // NaN表示 Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，数值超过了JavaScript的Number所能表示的最大值时，Infinity表示
```



`Infinity` 代表数学概念中的 `无穷大 ∞`。是一个比任何数字都大的特殊值。

```javascript
// 可以通过除以 0 来得到它：
console.log(1 / 0);

// 在代码中直接使用
console.log(Infinity);
```



`NaN` 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果

```javascript
console.log("hello" / 1);   // NaN

// NaN 是粘性的。任何对 NaN 的进一步操作都会返回 NaN： 
// 如果在数学表达式中有一个 NaN，会被传播到最终结果。
console.log( "not a number" / 2 + 5 ); // NaN
```



### String

JavaScript 中的字符串必须被括在引号里。

```javascript
let str1 = "hello";
let str2 = 'world';
let str3 = `hello ${str2}`;

console.log(`str1: ${str1}`);
console.log(`str2: ${str2}`);
console.log(`str3: ${str3}`);
```

在 JavaScript 中，有三种包含字符串的方式。

1. 双引号：`"Hello"`.
2. 单引号：`'Hello'`.
3. 反引号：\`Hello\`.   
   + `${…}`内的表达式会被计算，计算结果会成为字符串的一部分。

```javascript
// 反引号是 功能扩展 引号。它们允许我们通过将变量和表达式包装在 ${…} 中，来将它们嵌入到字符串中。
let userName = "ixfosa";
// 嵌入一个变量
console.log(`hello ${userName}`);
// 嵌入一个表达式
console.log(`the result is ${6 + 6}`)


// 需要注意的是，这仅仅在反引号内有效，其他引号不允许这种嵌入。
console.log( "the result is ${1 + 2}" ); // the result is ${1 + 2}
```



### Boolean

+ Boolean 类型：逻辑类型
+ boolean 类型仅包含两个值：`true` 和 `false`。

```java
let isHappiness = true;
let isLove = false;

// 布尔值也可作为比较的结果：
let isGreater = 6 > 1;
console.log(`isGreater ${isGreater}`) // isGreater true
```



### null

“null” 值

+ 一个独立的类型，只包含 `null` 值
+ 自成一种类型

```javascript
let myHeart = null; // myHeart是未知的。
```

> 相比较于其他编程语言，JavaScript 中的 null 不是一个“**对不存在的 object 的引用”或者 “null 指针**”。
>
> JavaScript 中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值。





### undefined

“undefined” 值

+ 特殊值 `undefined` 和 `null` 一样自成类型。
+ `undefined` 的含义是 `未被赋值`。

```javascript
// 如果一个变量已被声明，但未被赋值，那么它的值就是 undefined：
let gender;
console.log(`gender: ${gender}`)   // gender: undefined

// 可以显式地将 undefined 赋值给变量：
let age = 100;
// 将值修改为 undefined
age = undefined;
console.log(age); // undefined
```

```java
let x;

if (typeof v === "undefined") {
    console.log("x undefined");   // x undefined
}
```



### Object

+ 其他所有的数据类型都被称为“原始类型”，它们的值只包含一个单独的内容（字符串、数字或者其他）。
+ `object` 用于储存数据集合和更复杂的实体。



### typeof 运算符

+ `typeof` 运算符 返回参数的类型。

+ 持两种语法形式：
  + 作为运算符：`typeof x`。
  + 函数形式：`typeof(x)`。

```javascript
console.log(`number: ${typeof 0}`);      // number: number

console.log(`bigInt: ${typeof 0n}`);     // bigInt: bigint

console.log(`boolean: ${typeof true}`);  // boolean: boolean

console.log(`String: ${typeof "love"}`); // String: string


// 这是官方承认的 typeof 的行为上的错误，历史原因，为了兼容性而保留了下来。
// null 绝对不是一个 object。null 有自己的类型，它是一个特殊值。
console.log(`null: ${typeof null}`); // null: object

console.log(`undefined: ${typeof undefined}`); // undefined: undefined

console.log(`symbol: ${typeof Symbol("is")}`); // symbol: symbol

// Math 是一个提供数学运算的内建 object。
console.log(`object: ${typeof Math}`);         // object: object

console.log(`array: ${typeof [1, 2, 3]}`);     // array: object

// 空对象
console.log(`{ }: ${typeof {}}`);              // { }: object

// 在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 object 类型。
// 但是 typeof 会对函数区分对待，并返回 "function"。是来自于 JavaScript 语言早期的问题。
console.log(`function: ${typeof console.log}`) // function: function
```



## 类型转换

### 字符串转换

+ `String(value)` 将 value 转换为字符串类型

```java
// 显式地调用 String(value) 将 value 转换为字符串类型：
let isLove = true;
console.log(typeof isLove);

isLove = String(isLove);
console.log(typeof isLove);
// 字符串转换最明显。false 变成 "false"，null 变成 "null" 等。

// 
console.log(1 + "2"); 
```



### 数字型转换

+ `Number(value)` 显式转换为 number 类型。
+ 在算术函数和表达式中，会自动进行 number 类型转换。数字型转换遵循以下规则： 

```javascript
// 在算术函数和表达式中，会自动进行 number 类型转换。
console.log("6" / "2");
console.log(6 / "2");
console.log("6" / 2);
```

```javascript
// 使用 Number(value) 显式地将这个 value 转换为 number 类型。
let strNumber = "66";
console.log(typeof strNumber);   // string

strNumber = Number(strNumber);
console.log(typeof strNumber);   // number
```

```javascript
// 如果该字符串不是一个有效的数字，转换的结果会是 NaN。例如：
let age = "a123"
age = Number(age);
console.log(age);   // NaN，转换失败
console.log(typeof age);   // number

age = "123a"
age = Number(age);        // NaN
console.log(typeof age);  // number
```

number 类型转换规则：

| 值              | 变成……                                                       |
| :-------------- | :----------------------------------------------------------- |
| `undefined`     | `NaN`                                                        |
| `null`          | `0`                                                          |
| `true 和 false` | `1` and `0`                                                  |
| `string`        | 去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 `0`。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 `NaN`。 |

```java
console.log( Number("   123   ") ); // 123
console.log( Number("123z") );      // NaN（从字符串“读取”数字，读到 "z" 时出现错误）
console.log( Number(true) );        // 1
console.log( Number(false) );       // 0
```

```java
console.log(Number(undefined));  // NaN
console.log(Number(null));       // 0
console.log(Number(NaN));        // NaN
```

> 注意 `null` 和 `undefined` 在这有点不同：`null` 变成数字 `0`，`undefined` 变成 `NaN`。



### 布尔型转换

+  `Boolean(value)` 显式地进行转换

+ 转换规则如下：
  + 直观上为“空”的值（如 0、空字符串、null、undefined 和 NaN）将变为 false。
  + 其他值变成 true。

```javascript
console.log( Boolean(1) );       // true
console.log( Boolean(0) );       // false
console.log( Boolean("hello") ); // true
console.log( Boolean("") );      // false
console.log( Boolean(" ") );     // true
console.log( Boolean("0"));      // true
console.log( Boolean([]));       // true
console.log( Boolean({}) );      // true
```



## 运算符

### 相关术语

+ 运算元：运算符应用的对象

  ```javascript
  // 有两个运算元：左运算元 5 和右运算元 2。
  let num = 5 * 2
  ```

+ 一元运算符：一个运算符对应的只有一个运算元

  ```javascript
  // 对数字进行正负转换：
  let x = 1;
  x = -x;
  console.log(x); // -1，一元负号运算符生效

+ 二元运算符：一个运算符拥有两个运算元，

  ```javascript
  // 减号还存在二元运算符形式
  let n = 6;
  let m = 9;
  console.log(m - n);
  ```

  

### 数学运算符

+ 加法 +
+  减法 -
+ 乘法 *
+ 除法 /
+ 取余 %
+ 求幂 **

```javascript
// 取余 %
// a % b 的结果是 a 整除 b 的 余数。
console.log(5 % 2); // 1   5 除以 2 的余数
console.log(8 % 3); // 2


// 求幂 **
// 求幂运算 a ** b 是 a 乘以自身 b 次。
console.log(2 ** 2);  // 4  (2 * 2，自乘 2 次)
console.log(2 ** 3);  // 8
console.log(2 ** 4);  // 16

// 在数学上，求幂的定义也适用于非整数。例如，平方根是以 1/2 为单位的求幂：
console.log( 4 ** (1/2) ); // 2（1/2 次方与平方根相同)
console.log( 8 ** (1/3) ); // 2（1/3 次方与立方根相同)
```



### 二元 + 连接字符串

```javascript
// 加号 + 被应用于字符串，它将合并（连接）各个字符串
let myStr = "My" + "Str";
console.log(`mystr: ${myStr}`);
```

```java
// 注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。
console.log(1 + "2"); // "12"
console.log("2" + 1); // "21"
```

```java
// 运算符是按 从左向右 进行运算。
// 第一个 + 将两个数字相加，所以返回 4，然后下一个 + 将字符串 1 加入其中，
// 所以就是 4 + '1' = 41。
console.log(2 + 2 + '1' ); // "41"，不是 "221"
```

```javascript
// 二元 + 是唯一一个以这种方式支持字符串的算术运算符。
// 其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。

// 下面是减法和除法运算的示例：
console.log( 6 - '2' );    // 4，将 '2' 转换为数字
console.log( '6' / '2' );  // 3，将两个运算元都转换为数字
```



### 一元 + 数字转化

```javascript
// 加号 + 有两种形式。
	// 二元运算符，
	// 一元运算符。

// 一元运算符加号，对数字没有任何作用。
// 但是如果运算元不是数字，加号 + 则会将其转化为数字。
```

```javascript
// 对数字无效
let p = 1;
console.log(+p);

// 转化非数字, 效果和 Number(...) 相同
console.log(+true); // 1
console.log(+false); // 0
console.log(+"true"); // NaN
console.log(typeof +"66"); // number
```

```java
// 二元运算符加号会把它们合并成字符串：
let apples = "2";
let oranges = "3";
console.log( apples + oranges ); // "23"，二元运算符加号合并字符串

// 在二元运算符加号起作用之前，所有的值都被转化为了数字
console.log( +apples + +oranges ); // 5

console.log( Number(apples) + Number(oranges) ); // 5
```



### 赋值运算符

赋值 = 返回一个值

语句 x = value 将值 value 写入 x 然后返回 x。

```java
let a = 1;
let b = 2;
let c = 3 - (a = b + 1);

console.log( a ); // 3
console.log( c ); // 0
```

```javascript
// 链式赋值（Chaining assignments）
let n1, n2, n3;
n1 = n2 = n3 = 6;
console.log( n1 );
console.log( n2 );
console.log( n3 );
```

```javascript
// 原地修改
let n = 2;
n = n + 3;
n = n * 3;

// 所有算术和位运算符都有简短的“修改并赋值”运算符：/= 和 -= 等。
// 可以使用运算符 += 和 *= 来缩写这种表示。
n += 3;
n *= 3;

// 这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：
let num = 2;
num *= 3 + 5;
console.log( num ); // 16 （右边部分先被计算，等同于 n *= 8）
```



### 自增/自减

自增/自减只能应用于变量。

````javascript
// 自增 ++ 将变量与 1 相加
let counter1 = 2;
counter1++;      // 和 counter = counter + 1 效果一样，但是更简洁
console.log( counter1 ); // 3

// 自减 -- 将变量与 1 相减：
let counter2 = 2;
counter2--;      // 和 counter = counter - 1 效果一样，但是更简洁
console.log( counter2 ); // 1
````

```javascript
// 运算符 ++ 和 -- 可以置于变量前，也可以置于变量后。
    //- 当运算符置于变量后，被称为“后置形式”：counter++。
    //- 当运算符置于变量前，被称为“前置形式”：++counter。

// 前置形式返回一个新的值，但后置返回原来的值（做加法/减法之前的值）。
let counter3 = 1;
let a3 = ++counter3; 
console.log(a3); // 2

// 后置返回的是 旧值（做加法之前的值）。
let counter4 = 1;
let a4 = counter++; // (*) 将 ++counter 改为 counter++
console.log(a4); // 1
```

```java
// 如果自增/自减的值不会被使用，那么两者形式没有区别：
let counter5 = 0;
counter5++;
++counter5;
console.log( counter5 ); // 2，以上两行作用相同
```

```javascript
// 如果想要对变量进行自增操作，并且 需要立刻使用自增后的值，那么需要使用前置形式：
let counter6 = 0;
console.log( ++counter6 ); // 1

// 如果想要将一个数加一，但是想使用其自增之前的值，那么我们需要使用后置形式：
let counter7 = 0;
console.log( counter7++ ); // 0
```

````javascript
// 自增/自减和其它运算符的对比
// ++/-- 运算符同样可以在表达式内部使用。
let counter8 = 1;
console.log( 2 * ++counter8 ); // 4


let counter9 = 1;
console.log( 2 * counter9++ ); // 2，因为 counter++ 返回的是“旧值”
````



### 位运算符

位运算符把运算元当做 32 位整数，并在它们的二进制表现形式上操作。

位运算符：

+ 按位与 ( & )
+ 按位或 ( | )
+ 按位异或 ( ^ )
+ 按位非 ( ~ )
+ 左移 ( << )
+ 右移 ( >> )
+ 无符号右移 ( >>> )



### 逗号运算符

逗号运算符的优先级非常低，比 = 还要低

```java
// 如果没有圆括号：a = 1 + 2, 3 + 4 会先执行 +，将数值相加得到 a = 3, 7，
// 然后赋值运算符 = 执行, ‘a = 3’，然后逗号之后的数值 7 不会再执行，它被忽略掉了。
// 相当于 (a = 1 + 2), 3 + 4。

// 第一个语句 1 + 2 运行了，但是它的结果被丢弃了。随后计算 3 + 4，并且该计算结果被返回。
let foo =  (1 + 2, 3 + 4);
console.log(foo);   // 7
```



### 逻辑运算符

JavaScript 中有三个逻辑运算符

+ `||`（或）
+ `&&`（与）
+ `!`  （非）。

逻辑运算符可以被应用于任意类型的值，而不仅仅是布尔值。结果也同样可以是任意类型。



#### ||（或）

```javascript

// 如果参与运算的任意一个参数为 true，返回的结果就为 true，否则返回 false。
console.log( true || true );   // true
console.log( false || true );  // true
console.log( true || false );  // true
console.log( false || false ); // false

// 如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算。
	//- 例如，数字 1 被作为 true 处理，数字 0 则被作为 false：
if (1 || 0) { // 工作原理相当于 if( true || false )
    console.log( 'truthy!' );
}
```

```javascript
// 或运算寻找第一个真值
result = value1 || value2 || value3;
// 或运算符 || 做了如下的事情：
//- 从左到右依次计算操作数。
//- 处理每一个操作数时，都将其转化为布尔值。如果结果是 true，就停止计算，返回这个操作数的初始值。
//- 如果所有的操作数都被计算过（也就是，转换结果都是 false），则返回最后一个操作数。

// 返回的值是操作数的初始形式，不会做布尔转换

// 一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。
console.log( 1 || 0 ); // 1（1 是真值）
console.log( null || 1 ); // 1（1 是第一个真值）
console.log( null || 0 || 1 ); // 1（第一个真值）
console.log( undefined || null || 0 ); // 0（都是假值，返回最后一个值）

// 获取变量列表或者表达式中的第一个真值。
// 例如，有变量 firstName、lastName 和 nickName，都是可选的（即可以是 undefined、假值）。
// 如果所有变量的值都为假，结果就是 "Anonymous"。
let firstName = "";
let lastName = "";
let nickName = "SuperCoder";
console.log( firstName || lastName || nickName || "Anonymous"); // SuperCoder
```

```javascript
// 短路求值（Short-circuit evaluation）。

// 或运算符 || 在遇到 true 时立即停止运算，所以  console.log 没有运行。
true || console.log("not printed");
//  console.log 运行。
false || console.log("printed");
```

#### &&（与）

+ 与运算 && 的优先级比或运算 || 要高。

```javascript
console.log( true && true );   // true
console.log( false && true );  // false
console.log( true && false );  // false
console.log( false && false ); // false

// 像或运算一样，与运算的操作数可以是任意类型的值：
if (1 && 0) { // 作为 true && false 来执行
    console.log( "won't work, because the result is falsy" );
}
```

```javascript
// 与运算寻找第一个假值
result = value1 && value2 && value3;
// 与运算 && 做了如下的事：
//- 从左到右依次计算操作数。
//- 在处理每一个操作数时，都将其转化为布尔值。如果结果是false，就停止计算，并返回这个操作数的初始值。
//- 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。
//- 换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值。

// 如果第一个操作数是真值，
// 与运算返回第二个操作数：
console.log( 1 && 0 ); // 0
console.log( 1 && 5 ); // 5

// 如果第一个操作数是假值，
// 与运算将直接返回它。第二个操作数会被忽略
console.log( null && 5 ); // null
console.log( 0 && "no matter what" ); // 0

console.log( 1 && 2 && null && 3 ); // null

// 如果所有的值都是真值，最后一个值将会被返回：
console.log( 1 && 2 && 3 ); // 3，最后一个值
```

```javascript
// 与运算 && 在或运算 || 之前进行
// 与运算 && 的优先级比或运算 || 要高。
	//- a && b || c && d 跟 && 表达式加了括号完全一样：(a && b) || (c && d)。	


```

```javascript
// 不要用 || 或 && 来取代 if
let x = 1;
(x > 0) && console.log( 'Greater than zero!' );

// && 右边的代码只有运算抵达到那里才能被执行。也就是，当且仅当 (x > 0) 为真。
let x = 1;
if (x > 0) console.log( 'Greater than zero!' );
```

####  !（非）

+  非运算符 ! 的优先级在所有逻辑运算符里面最高，所以它总是在 && 和 || 之前执行。

```javascript
// result = !value;
// 逻辑非运算符接受一个参数，并按如下运作：
    //- 将操作数转化为布尔类型：true/false。
    //- 返回相反的值。
console.log( !true ); // false
console.log( !0 ); // true
```

```javascript
// 两个非运算 !! 有时候用来将某个值转化为布尔类型：
console.log( !!"non-empty string" ); // true
console.log( !!null ); // false

console.log( Boolean("non-empty string") ); // true
console.log( Boolean(null) ); // false
```



#### 逻辑运算符练习

```javascript
console.log( 1 && null && 2 );
//- 答案：null，因为它是列表中第一个假值。
```

```javascript
console.log( console.log(1) && console.log(2) ); // 1, undefined
//- 答案：1，然后 undefined。
    //- 调用 console.log 返回了 undefined（它只展示消息，所以没有有意义的返回值）。
    //- 因此，&& 计算了它左边的操作数（显示 1），然后立即停止了，因为 undefined 是一个假值
    //- && 就是寻找假值然后返回它，所以运算结束。
```

```javascript
console.log( null || 2 && 3 || 4 ); // 答案：3。
//- 与运算 && 的优先级比 || 高，所以它第一个被执行。
//- 结果是 2 && 3 = 3，所以表达式变成了：
null || 3 || 4   // 现在的结果就是第一个真值：3。
```

```javascript
// 写一个 if 条件句，检查 age 是否不位于 14 到 90 的闭区间。
// 创建两个表达式：第一个用非运算 !，第二个不用。

// 第一个表达式：
if (!(age >= 14 && age <= 90))

// 第二个表达式：
if (age < 14 || age > 90)
```

```javascript
// 下面哪一个 alert 将会被执行？

// if(...) 语句内表达式的结果是什么？
if (-1 || 0) console.log( 'first' );  // // -1 || 0 的结果为 -1，真值
if (-1 && 0) console.log( 'second' ); // // -1 && 0 = 0，假值
if (null || -1 && 1) console.log( 'third' ); // null || -1 && 1  ->  null || 1  ->  1
//- 答案：第一个和第三个将会被执行。
```





### 空值合并运算符 '??'

这里，将值既不是 null 也不是 undefined 的表达式称为“已定义的（defined）”。

```javascript
// a ?? b 的结果是：
    //- 如果 a 是已定义的，则结果为 a，
    //- 如果 a 不是已定义的，则结果为 b。
// 换句话说，如果第一个参数不是 null/undefined，则 ?? 返回第一个参数。否则，返回第二个参数。

// 使用已知的运算符重写 result = a ?? b，像这样：
result = (a !== null && a !== undefined) ? a : b;
```

```javascript
// 通常 ?? 的使用场景是，为可能是未定义的变量提供一个默认值。
// 例如，在这里，如果 user 是未定义的，则显示 long：
let user;
console.log(user ?? "long"); // long

// 如果 user 的值为除 null/undefined 外的任意值，那么我们看到的将是它：
user = "zhong";
console.log(user ?? "long"); // zhong
```

```javascript
// 使用 ?? 序列从一系列的值中选择出第一个非 null/undefined 的值。
let firstName = null;
let lastName = null;
let nickName = "梓晴";
// 显示第一个已定义的值：
console.log(firstName ?? lastName ?? nickName ?? "如也"); // 梓晴
            
// 与 || 比较
// 或运算符 || 可以以与 ?? 运算符相同的方式使用。
// 例如，在上面的代码中，我们可以用 || 替换掉 ??，也可以获得相同的结果：
console.log(firstName || lastName || nickName || "如也"); // 梓晴
          
//- 它们之间重要的区别是：
    //- || 返回第一个 真 值。
    //- ?? 返回第一个 已定义的 值。
            
// || 无法区分 false、0、空字符串 "" 和 null/undefined。它们都一样 —— 假值（falsy values）。
// 如果其中任何一个是 || 的第一个参数，// 那么将得到第二个参数作为结果。

// 在实际中，可能只想在变量的值为 null/undefined 时使用默认值。
// 也就是说，当该值确实未知或未被设置时。

// 如果高度 0 为有效值，则不应将其替换为默认值，所以 ?? 能够得出正确的结果。
let height = 0;
console.log(height || 100); // 100
console.log(height ?? 100); // 0
```

```java
// 优先级
let h = null;
let w = null;
let area;
// 重要：使用括号
area = (h ?? 100) * (w ?? 50);
console.log(area); // 5000

// 否则，如果我们省略了括号，则由于 * 的优先级比 ?? 高，它会先执行，进而导致错误的结果。
// 没有括号
// area = h1 ?? 100 * w1 ?? 50; // ReferenceError: h1 is not defined
// console.log(area);

// ……与下面这行代码的计算方式相同（应该不是我们所期望的）：
// area = h2 ?? (100 * w2) ?? 50; // ReferenceError: h2 is not defined
// console.log(area);


// ?? 与 && 或 || 一起使用
    //- 出于安全原因，JavaScript 禁止将 ?? 运算符与 && 和 || 运算符一起使用，除非使用括号明确指定了优先级。

//下面的代码会触发一个语法错误：
let x = 1 && 2 ?? 3; // Syntax error
// 这个限制无疑是值得商榷的，但它被添加到语言规范中是为了避免人们从 || 切换到 ?? 时的编程错误。

// 可以明确地使用括号来解决这个问题：
let y = (1 && 2) ?? 3; // 正常工作了

console.log(y); // 2
```

```javascript
// 优先级
let h = null;
let w = null;
let area;
// 重要：使用括号
area = (h ?? 100) * (w ?? 50);
console.log(area); // 5000
// 如果我们省略了括号，则由于 * 的优先级比 ?? 高，它会先执行，进而导致错误的结果。

// 没有括号
area = h ?? 100 * w ?? 50;
console.log(area);  // 0

area = h2 ?? (100 * w2) ?? 50; 
console.log(area);  // 0
```

```javascript
// ?? 与 && 或 || 一起使用
//- 出于安全原因，禁止将 ?? 运算符与 && 和 || 运算符一起使用，除非使用括号明确指定了优先级。

// 下面的代码会触发一个语法错误：
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'

// 可以明确地使用括号来解决这个问题：
let y = (1 && 2) ?? 3;
console.log(y); // 2
```



###  运算符优先级

如果一个表达式拥有超过一个运算符，执行的顺序则由 优先级 决定。

+ **一元运算符优先级高于二元运算符**



## 条件分支

### if 



### 条件运算符 ‘?’



### switch



## 循环

### while 

###  for



