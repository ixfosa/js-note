
// 术语：“一元运算符”，“二元运算符”，“运算元”

// 运算元 —— 运算符应用的对象。比如说乘法运算 5 * 2，有两个运算元：左运算元 5 和右运算元 2。
// 有时候人们也称其为“参数”而不是“运算元”。

// 如果一个运算符对应的只有一个运算元，那么它是 一元运算符。比如说一元负号运算符（unary negation）-，
// 它的作用是对数字进行正负转换：
let x = 1;
x = -x;
console.log(x); // -1，一元负号运算符生效

// 如果一个运算符拥有两个运算元，那么它是 二元运算符。减号还存在二元运算符形式：
let n = 6;
let m = 9;
console.log(m - n);



/**
    数学
        支持以下数学运算：
            加法 +,
            减法 -,
            乘法 *,
            除法 /,
            取余 %,
            求幂 **.
 */


// 取余 %
// 取余运算符是 %，尽管它看起来很像百分数，但实际并无关联。
// a % b 的结果是 a 整除 b 的 余数)。
console.log(5 % 2); // 1   5 除以 2 的余数
console.log(8 % 3); // 2


// 求幂 **
// 求幂运算 a ** b 是 a 乘以自身 b 次。
console.log(2 ** 2);  // 4  (2 * 2，自乘 2 次)
console.log(2 ** 3);  // 8
console.log(2 ** 4);  // 16

// 在数学上，求幂的定义也适用于非整数。例如，平方根是以 1/2 为单位的求幂：
console.log( 4 ** (1/2) ); // 2（1/2 次方与平方根相同)
console.log( 8 ** (1/3) ); // 2（1/3 次方与立方根相同)




//用二元运算符 + 连接字符串
// 通常，加号 + 用于求和。
// 但是如果加号 + 被应用于字符串，它将合并（连接）各个字符串：
let myStr = "My" + "Str";
console.log(`mystr: ${myStr}`);

// 注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。
console.log(1 + "2"); // "12"
console.log("2" + 1); // "21"

// 运算符是按顺序工作。第一个 + 将两个数字相加，所以返回 4，然后下一个 + 将字符串 1 加入其中，
// 所以就是 4 + '1' = 41。
console.log(2 + 2 + '1' ); // "41"，不是 "221"


// 二元 + 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。

//下面是减法和除法运算的示例：
console.log( 6 - '2' );    // 4，将 '2' 转换为数字
console.log( '6' / '2' );  // 3，将两个运算元都转换为数字




// 数字转化，一元运算符 +

// 加号 + 有两种形式。一种是上面我们刚刚讨论的二元运算符，还有一种是一元运算符。
// 一元运算符加号，或者说，加号 + 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 + 则会将其转化为数字。

// 对数字无效
let p = 1;
console.log(+p);

let q = 2;
console.log(+q);

// 转化非数字
console.log(+true); // 1
console.log(+false); // 0
console.log(+"true"); // NaN
console.log(typeof +"66"); // number


// 二元运算符加号会把它们合并成字符串：
let apples = "2";
let oranges = "3";
console.log( apples + oranges ); // "23"，二元运算符加号合并字符串

// 在二元运算符加号起作用之前，所有的值都被转化为了数字
console.log( +apples + +oranges ); // 5

// 更长的写法
// alert( Number(apples) + Number(oranges) ); // 5




// 运算符优先级

/**
    如果一个表达式拥有超过一个运算符，执行的顺序则由 优先级 决定。
    换句话说，所有的运算符中都隐含着优先级顺序。

    要记住一元运算符优先级高于二元运算符

 */


 // 赋值运算符

// 赋值 = 返回一个值
// 是一个运算符，而不是一个有着“魔法”作用的语言结构。
// 语句 x = value 将值 value 写入 x 然后返回 x。

let a = 1;
let b = 2;
let c = 3 - (a = b + 1);

console.log( a ); // 3
console.log( c ); // 0


// 链式赋值（Chaining assignments）
let n1, n2, n3;
n1 = n2 = n3 = 6;
console.log( n1 );
console.log( n2 );
console.log( n3 );



// 原地修改
// let n = 2;
n = n + 3;
n = n * 3;

// 所有算术和位运算符都有简短的“修改并赋值”运算符：/= 和 -= 等。
// 可以使用运算符 += 和 *= 来缩写这种表示。
n += 3;
n *= 3;

// 这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：
let num = 2;
num *= 3 + 5;
console.log( num ); // 16 （右边部分先被计算，等同于 n *= 8）




// 自增/自减
// 自增/自减只能应用于变量。试一下，将其应用于数值（比如 5++）则会报错。

// 自增 ++ 将变量与 1 相加：
let counter1 = 2;
counter1++;      // 和 counter = counter + 1 效果一样，但是更简洁
console.log( counter1 ); // 3

// 自减 -- 将变量与 1 相减：
let counter2 = 2;
counter2--;      // 和 counter = counter - 1 效果一样，但是更简洁
console.log( counter2 ); // 1


// 运算符 ++ 和 -- 可以置于变量前，也可以置于变量后。
    //- 当运算符置于变量后，被称为“后置形式”：counter++。
    //- 当运算符置于变量前，被称为“前置形式”：++counter。

// 前置形式返回一个新的值，但后置返回原来的值（做加法/减法之前的值）。
let counter3 = 1;
let a3 = ++counter3; // (*)
console.log(a3); // 2

// 后置返回的是 旧值（做加法之前的值）。因此 alert 显示的是 1。

let counter4 = 1;
let a4 = counter4++; // (*) 将 ++counter 改为 counter++
console.log(a4); // 1

// 如果自增/自减的值不会被使用，那么两者形式没有区别：
let counter5 = 0;
counter5++;
++counter5;
console.log( counter5 ); // 2，以上两行作用相同


// 如果我们想要对变量进行自增操作，并且 需要立刻使用自增后的值，那么我们需要使用前置形式：
let counter6 = 0;
console.log( ++counter6 ); // 1

// 如果我们想要将一个数加一，但是我们想使用其自增之前的值，那么我们需要使用后置形式：
let counter7 = 0;
console.log( counter7++ ); // 0


// 自增/自减和其它运算符的对比
// ++/-- 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。
let counter8 = 1;
console.log( 2 * ++counter8 ); // 4


let counter9 = 1;
console.log( 2 * counter9++ ); // 2，因为 counter++ 返回的是“旧值”




// 位运算符
// 位运算符把运算元当做 32 位整数，并在它们的二进制表现形式上操作。
//- 下面是位运算符：
    //- 按位与 ( & )
    //- 按位或 ( | )
    //- 按位异或 ( ^ )
    //- 按位非 ( ~ )
    //- 左移 ( << )
    //- 右移 ( >> )
    //- 无符号右移 ( >>> )



// 逗号运算符
/**
    逗号运算符的优先级非常低
    请注意逗号运算符的优先级非常低，比 = 还要低，因此上面你的例子中圆括号非常重要。

    如果没有圆括号：a = 1 + 2, 3 + 4 会先执行 +，将数值相加得到 a = 3, 7，
    然后赋值运算符 = 执行, ‘a = 3’，然后逗号之后的数值 7 不会再执行，它被忽略掉了。
    相当于 (a = 1 + 2), 3 + 4。
 */
// 第一个语句 1 + 2 运行了，但是它的结果被丢弃了。随后计算 3 + 4，并且该计算结果被返回。
let foo =  (1 + 2, 3 + 4);
console.log(foo);

