
// 构造器和操作符 "new"
    //- 常规的 {...} 语法允许创建一个对象。但是我们经常需要创建许多类似的对象，例如多个用户或菜单项等。
    // 这可以使用构造函数和 "new" 操作符来实现。



// 构造函数
    //- 构造函数在技术上是常规函数。不过有两个约定：
        //- 它们的命名以大写字母开头。
        //- 它们只能由 "new" 操作符来执行。

function User(name) {
    this.name = name;
    this.isAdmin = true;
}

user = new User("ixfosa");
console.log(user.name);
console.log(user.isAdmin);


let user2 = {
    name: "Jack",
    isAdmin: false
};

// -------------------------------------------------------------------------------------------



// 当一个函数被使用 new 操作符执行时，它按照以下步骤：
    //- 一个新的空对象被创建并分配给 this。
    //- 函数体执行。通常它会修改 this，为其添加新的属性。
    //- 返回 this 的值。

function ClassName(attr1, attr2) {

    // this = {};（隐式创建）

    // 添加属性到 this
    this.attr1;
    this.attr2;
    // ... 

    // return this;（隐式返回）
}

// 构造器的主要目的 —— 实现可重用的对象创建代码。
// 从技术上讲，任何函数都可以用作构造器。即：任何函数都可以通过 new 来运行，它会执行上面的算法。
// “首字母大写”是一个共同的约定，以明确表示一个函数将被使用 new 来运行。



// new function() { … }
// 如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在构造函数中，像这样：
let user3 = new function() {
  this.name = "long";
  this.isAdmin = false;

  // ……用于用户创建的其他代码
  // 也许是复杂的逻辑和语句
  // 局部变量等
};

// 构造器不能被再次调用，因为它不保存在任何地方，只是被创建和调用。
// 因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。




// -------------------------------------------------------------------------------------------



// 构造器模式测试：new.target
    //- 在一个函数内部，我们可以使用 new.target 属性来检查它是否被使用 new 进行调用了。

// 对于常规调用，它为空，对于使用 new 的调用，则等于该函数：
function Person() {
    console.log(new.target);
}

// 不带 "new"：
Person(); // undefined

// 带 "new"：
p =new Person(); // [Function: Person]


// 它可以被用在函数内部，来判断该函数是被通过 new 调用的“构造器模式”，还是没被通过 new 调用的“常规模式”。
// 也可以让 new 调用和常规调用做相同的工作，像这样：

function Person2(name) {
    if (!new.target) {
        return new Person2(name);
    }
    this.name = name;
}

// 这样人们在调用函数时，无论是否使用了 new，程序都能工作。
// 到处都使用它并不是一件好事，因为省略了 new 使得很难观察到代码中正在发生什么。
// 而通过 new 我们都可以知道这创建了一个新对象。




// -------------------------------------------------------------------------------------------


// 构造器的 return
    //- 通常，构造器没有 return 语句。它们的任务是将所有必要的东西写入 this，并自动转换为结果。

    //- 但是，如果这有一个 return 语句，那么规则就简单了：
        //- 如果 return 返回的是一个对象，则返回这个对象，而不是 this。
        //- 如果 return 返回的是一个原始类型，则忽略。
        //- 换句话说，带有对象的 return 返回该对象，在所有其他情况下返回 this。

// 例如，这里 return 通过返回一个对象覆盖 this：
function Student() {
    this.name = "zhong";

    return {
        name: "long",
    }
}

console.log(new Student().name); // long

//  return 为空的例子（或者可以在它之后放置一个原始类型，没有什么影响）：
function Student2() {

    this.name = "zhong";

    return true;
}

console.log(new Student2().name); // zhong



// 省略括号
    // 如果没有参数，我们可以省略 new 后的括号：
function P() {

}

let p1 = new P; // <-- 没有参数
// 等同于
let p2 = new P();
// 这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。




// -------------------------------------------------------------------------------------------




// 构造器中的方法
    //- 创建对象会带来使用构造函数来很大的灵活性。构造函数可能有一些参数，这些参数定义了如何构造对象以及要放入什么。

    // 当然，我们不仅可以将属性添加到 this 中，还可以添加方法。



// 例如，下面的 new User(name) 用给定的 name 和方法 sayHi 创建了一个对象：
function Animal(name) {
  this.name = name;

  this.sayHi = function() {
    console.log( "My name is: " + this.name );
  };
}

let cat = new Animal("mm");

cat.sayHi(); // My name is: mm

/*
cat = {
   name: "mm",
   sayHi: function() { ... }
}
*/


// -------------------------------------------------------------------------------------------


// 总结
    //- 构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其`命名首字母要大写`。
    //- 构造函数只能使用 `new` 来调用。这样的调用意味着在开始时创建了空的 this，并在最后返回填充了值的 this。
    //- 我们可以使用构造函数来创建多个类似的对象。



// -------------------------------------------------------------------------------------------