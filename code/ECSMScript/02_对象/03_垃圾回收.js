//垃圾回收
    //- 对于开发者来说，JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数……这一切都会占用内存。

// 可达性（Reachability）
    //- JavaScript 中主要的内存管理概念是 可达性。

    //- 简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。

    //- 这里列出固有的可达值的基本集合，这些值明显不能被释放。
    //- 比方说：
        //- 当前函数的局部变量和参数。
        //- 嵌套调用时，当前调用链上所有函数的变量与参数。
        //- 全局变量。
        //- （还有一些内部的）
        //- 这些值被称作 根（roots）。

    //- 如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的。

    //- 比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 该 对象被认为是可达的。
    //- 而且它引用的内容也是可达的。下面是详细的例子。

    //- 在 JavaScript 引擎中有一个被称作 垃圾回收器 的东西在后台执行。
    //- 它监控着所有对象的状态，并删除掉那些已经不可达的




// user 具有对这个对象的引用
let user = {
    name: "John"
};

// 全局变量 "user" 引用了对象 {name："John"}（为简洁起见，我们称它为 John）。
// John 的 "name" 属性存储一个原始值，所以它被写在对象内部。

// 如果 user 的值被重写了，这个引用就没了：
// user = null;

//现在 John 变成不可达的了。因为没有引用了，就不能访问到它了。
// 垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。



// 两个引用,把 user 的引用复制给 admin：
let admin = user;
user = null;
// 然后对象仍然可以被通过 admin 这个全局变量访问到，所以对象还在内存中。
// 如果我们又重写了 admin，对象就会被删除。




// -------------------------------------------------------------------------------------------



// 相互关联的对象

// 现在来看一个更复杂的例子。这是个家庭：
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});

// marry 函数通过让两个对象相互引用使它们“结婚”了，并返回了一个包含这两个对象的新对象。

// 目前为止，所有对象都是可达的。
// 移除两个引用：
delete family.father;
delete family.mother.husband;

// 仅删除这两个引用中的一个是不够的，因为所有的对象仍然都是可达的。

// 但是，如果我们把这两个都删除，那么我们可以看到再也没有对 John 的引用了：

// 对外引用不重要，只有传入引用才可以使对象可达。所以，John 现在是不可达的，并且将被从内存中删除，
// 同时 John 的所有数据也将变得不可达。




// 无法到达的岛屿
    // 几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。
    // 源对象与上面相同。然后：
family = null;

// John 和 Ann 仍然连着，都有传入的引用。但是，这样还不够。
// 前面说的 "family" 对象已经不再与根相连，没有了外部对其的引用，所以它变成了一座“孤岛”，并且将被从内存中删除。



// -------------------------------------------------------------------------------------------



// 内部算法

//- 垃圾回收的基本算法被称为 “mark-and-

//-定期执行以下“垃圾回收”步骤：
    //- 垃圾收集器找到所有的根，并“标记”（记住）它们。
    //- 然后它遍历并“标记”来自它们的所有引用。
    //- 然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
    //- ……如此操作，直到所有可达的（从根部）引用都被访问到。
    //- 没有被标记的对象都会被删除。



//- 分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。许多对象出现，
    //- 完成它们的工作并很快死去，它们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。

//- 增量收集（Incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，
    //- 则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。
    //- 然后将这几部分会逐一进行处理。这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延
    //- 迟而不是一个大的延迟。

//- 闲时收集（Idle-time collection）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。



// -------------------------------------------------------------------------------------------