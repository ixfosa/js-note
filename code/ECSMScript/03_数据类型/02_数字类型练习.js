
// 为什么 6.35.toFixed(1) == 6.3？
    // 在内部，6.35 的小数部分是一个无限的二进制。在这种情况下，它的存储会造成精度损失。
console.log( 6.35.toFixed(20) ); // 6.34999999999999964473
// 精度损失可能会导致数字的增加和减小。在这种特殊的情况下，数字变小了一点，这就是它向下舍入的原因。



// 根据文档，Math.round 和 toFixed 都将数字舍入到最接近的数字：0..4 会被舍去，而 5..9 会进一位。
console.log( 1.35.toFixed(1) ); // 1.4

console.log( 1.35.toFixed(20) ); // 1.35000000000000008882
// 在这里，精度损失使得这个数字稍微大了一些，因此其向上舍入。



// 在下面这个类似的示例中，为什么 6.35 被舍入为 6.3 而不是 6.4？
console.log( 6.35.toFixed(1) ); // 6.3

// 如何以正确的方式来对 6.35 进行舍入？

// 在进行舍入前，我们应该使其更接近整数：

console.log( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000

// 请注意，63.5 完全没有精度损失。这是因为小数部分 0.5 实际上是 1/2。
// 以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确地表示，现在我们可以对它进行舍入：
console.log( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4




// -------------------------------------------------------------------------------------------


// 一个偶发的无限循环

// 这是一个无限循环。它永远不会结束。为什么？

let i = 0;
while (i != 10) {
  i += 0.2;
}

// 它们中没有一个恰好是 10。
// 之所以发生这种情况，是因为对 0.2 这样的小数时进行加法运算时出现了精度损失。
// 结论：在处理小数时避免相等性检查。


// 重复，直到输入的是一个数字

// 创建一个函数 readNumber，它提示输入一个数字，直到访问者输入一个有效的数字为止。
// 结果值必须以数字形式返回。

// 访问者也可以通过输入空行或点击“取消”来停止该过程。在这种情况下，函数应该返回 null。

function readNumber() {
    let num;

    do {
      num = prompt("Enter a number please?", 0);
    } while ( !isFinite(num) );

    if (num === null || num === '') return null;

    return +num;
}

alert(`Read: ${readNumber()}`);